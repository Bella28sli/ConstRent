# Generated by Django 5.2.7 on 2025-11-22 13:14

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('rental_system', '0001_initial'),
    ]

    operations = [
        # Функции
        migrations.RunSQL("""
            CREATE OR REPLACE FUNCTION get_client_rental_history(
                p_client_id INT
            )
            RETURNS TABLE(
                rent_id INT,
                agreement_number VARCHAR,
                start_date DATE,
                end_date DATE,
                equipment_names TEXT,
                total_amount NUMERIC,
                status VARCHAR
            ) AS $$
            BEGIN
                RETURN QUERY
                SELECT 
                    r.id,
                    r.rent_agreement_number,
                    r.start_date,
                    COALESCE(r.actual_end_date, r.planned_end_date) as end_date,
                    STRING_AGG(e.equipment_name, ', ') as equipment_names,
                    r.total_amount,
                    r.rent_status
                FROM rental_system_rent r
                JOIN rental_system_rentitems ri ON r.id = ri.rent_id
                JOIN rental_system_equipment e ON ri.equipment_id = e.id
                WHERE r.client_id = p_client_id
                GROUP BY r.id, r.rent_agreement_number, r.start_date, r.actual_end_date, r.planned_end_date, r.total_amount, r.rent_status
                ORDER BY r.start_date DESC;
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS get_client_rental_history(INT);
        """),

        migrations.RunSQL("""
            CREATE OR REPLACE FUNCTION calculate_rental_cost(
                p_equipment_ids INT[],
                p_start_date DATE,
                p_end_date DATE
            )
            RETURNS NUMERIC AS $$
            DECLARE
                v_total_cost NUMERIC := 0;
                v_equipment_id INT;
                v_duration INT;
                v_daily_price NUMERIC;
            BEGIN
                v_duration := p_end_date - p_start_date;
                
                FOREACH v_equipment_id IN ARRAY p_equipment_ids LOOP
                    SELECT rental_price_day INTO v_daily_price 
                    FROM rental_system_equipment 
                    WHERE id = v_equipment_id;
                    
                    v_total_cost := v_total_cost + (v_daily_price * v_duration);
                END LOOP;
                
                RETURN v_total_cost;
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS calculate_rental_cost(INT[], DATE, DATE);
        """),

        migrations.RunSQL("""
            CREATE OR REPLACE FUNCTION calculate_late_fee(
                p_rent_id BIGINT,
                p_penalty_rate NUMERIC DEFAULT 0.1
            )
            RETURNS NUMERIC AS $$
            DECLARE
                v_days_late INT;
                v_total_amount NUMERIC;
                v_penalty NUMERIC;
            BEGIN
                SELECT 
                    CURRENT_DATE - planned_end_date,
                    total_amount
                INTO v_days_late, v_total_amount
                FROM rental_system_rent
                WHERE id = p_rent_id
                AND actual_end_date IS NULL
                AND planned_end_date < CURRENT_DATE;
                
                IF v_days_late > 0 THEN
                    v_penalty := v_total_amount * p_penalty_rate * v_days_late;
                ELSE
                    v_penalty := 0;
                END IF;
                
                RETURN v_penalty;
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS calculate_late_fee(BIGINT, NUMERIC);
        """),

        migrations.RunSQL("""
            CREATE OR REPLACE FUNCTION generate_agreement_number()
            RETURNS VARCHAR AS $$
            DECLARE
                v_year VARCHAR := EXTRACT(YEAR FROM CURRENT_DATE)::VARCHAR;
                v_sequence INT;
                v_agreement_number VARCHAR;
            BEGIN
                SELECT COALESCE(MAX(SUBSTRING(rent_agreement_number FROM '[0-9]+$')::INT), 0) + 1
                INTO v_sequence
                FROM rental_system_rent
                WHERE rent_agreement_number LIKE 'A-' || v_year || '-%';
                
                v_agreement_number := 'A-' || v_year || '-' || LPAD(v_sequence::VARCHAR, 4, '0');
                
                RETURN v_agreement_number;
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS generate_agreement_number();
        """),

        migrations.RunSQL("""
            -- Функция для ручного логирования сложных операций
            CREATE OR REPLACE FUNCTION log_custom_action(
                p_staff_id INT,
                p_action_type TEXT,
                p_description TEXT,
                p_success BOOLEAN DEFAULT TRUE
            )
            RETURNS VOID AS $$
            BEGIN
                INSERT INTO rental_system_log(
                    staff_id,
                    action_type, 
                    description_text,
                    success_status
                ) VALUES (
                    p_staff_id,
                    p_action_type,
                    p_description,
                    p_success
                );
            END;
            $$ LANGUAGE plpgsql;

            -- Функция для логирования операций с файлами
            CREATE OR REPLACE FUNCTION log_file_operation(
                p_staff_id INT,
                p_action_type TEXT,
                p_filename TEXT,
                p_success BOOLEAN DEFAULT TRUE
            )
            RETURNS VOID AS $$
            BEGIN
                INSERT INTO rental_system_log(
                    staff_id,
                    action_type, 
                    description_text,
                    success_status
                ) VALUES (
                    p_staff_id,
                    p_action_type,
                    CONCAT('Файл: ', p_filename, '. Действие: ', p_action_type),
                    p_success
                );
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS log_custom_action;
            DROP FUNCTION IF EXISTS log_file_operation;
        """),
        
        migrations.RunSQL("""
            CREATE OR REPLACE FUNCTION update_equipment_status(
                p_equipment_id INT,
                p_new_status VARCHAR,
                p_staff_id INT
            )
            RETURNS VOID AS $$
            BEGIN
                UPDATE rental_system_equipment
                SET status = p_new_status
                WHERE id = p_equipment_id;
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS update_equipment_status;
        """),
        

        # Представления
        migrations.RunSQL("""
            CREATE OR REPLACE VIEW equipment_status_view AS
            SELECT 
                e.id AS equipment_id,
                e.equipment_name,
                e.status,
                m.model_name,
                b.brand,
                c.country,
                r.rent_status
            FROM rental_system_equipment e
            LEFT JOIN rental_system_equipmentmodels m ON e.model_id = m.id
            LEFT JOIN rental_system_equipmentbrands b ON e.brand_id = b.id
            LEFT JOIN rental_system_equipmentcountries c ON e.country_id = c.id
            LEFT JOIN rental_system_rentitems ri ON ri.equipment_id = e.id
            LEFT JOIN rental_system_rent r ON ri.rent_id = r.id;
        """, """
            DROP VIEW IF EXISTS equipment_status_view;
        """),

        
        migrations.RunSQL("""
            CREATE OR REPLACE VIEW staff_logs_view AS
            SELECT
                u.id AS staff_id,
                u.first_name,
                u.last_name,
                u.username,
                l.log_date,
                l.action_type,
                l.success_status,
                l.description_text
            FROM auth_user u
            LEFT JOIN rental_system_log l ON l.staff_id = u.id;
        """, """
            DROP VIEW IF EXISTS staff_logs_view;
        """),

        migrations.RunSQL("""
            CREATE OR REPLACE VIEW client_rent_view AS
            SELECT
                cl.id AS client_id,
                cl.email,
                cl.phone_number,
                CASE 
                    WHEN cl.type = 'individual' THEN 
                        CONCAT(ind.last_name, ' ', ind.first_name, 
                            CASE WHEN ind.patronymic IS NOT NULL THEN ' ' || ind.patronymic ELSE '' END)
                    WHEN cl.type = 'company' THEN comp.company_name
                    ELSE 'Неизвестный тип клиента'
                END AS client_name,
                cl.type AS client_type,
                r.id AS rent_id,
                r.rent_agreement_number,
                r.start_date,
                r.planned_end_date,
                r.actual_end_date,
                r.rent_status,
                e.equipment_name,
                e.equipment_code
            FROM rental_system_client cl
            LEFT JOIN rental_system_rent r ON r.client_id = cl.id
            LEFT JOIN rental_system_rentitems ri ON ri.rent_id = r.id
            LEFT JOIN rental_system_equipment e ON ri.equipment_id = e.id
            LEFT JOIN rental_system_indclient ind ON ind.client_id = cl.id AND cl.type = 'individual'
            LEFT JOIN rental_system_compclient comp ON comp.client_id = cl.id AND cl.type = 'company';
        """, """
            DROP VIEW IF EXISTS client_rent_view;
        """),

        migrations.RunSQL("""
            CREATE OR REPLACE VIEW equipment_return_debt_view AS
            SELECT
                cl.id AS client_id,
                cl.email,
                cl.phone_number,
                CASE 
                    WHEN cl.type = 'individual' THEN 
                        CONCAT(ind.last_name, ' ', ind.first_name, 
                            CASE WHEN ind.patronymic IS NOT NULL THEN ' ' || ind.patronymic ELSE '' END)
                    WHEN cl.type = 'company' THEN comp.company_name
                    ELSE 'Неизвестный тип клиента'
                END AS client_name,
                cl.type AS client_type,
                r.id AS rent_id,
                r.rent_agreement_number,
                r.start_date,
                r.planned_end_date,
                COALESCE(r.actual_end_date, CURRENT_DATE) AS return_date,
                e.equipment_name,
                e.equipment_code,
                (CURRENT_DATE - r.planned_end_date) AS days_overdue,
                calculate_late_fee(r.id, 0.1) AS late_fee
            FROM rental_system_rent r
            JOIN rental_system_client cl ON r.client_id = cl.id
            JOIN rental_system_rentitems ri ON ri.rent_id = r.id
            JOIN rental_system_equipment e ON ri.equipment_id = e.id
            LEFT JOIN rental_system_indclient ind ON ind.client_id = cl.id AND cl.type = 'individual'
            LEFT JOIN rental_system_compclient comp ON comp.client_id = cl.id AND cl.type = 'company'
            WHERE r.actual_end_date IS NULL AND r.planned_end_date < CURRENT_DATE;
        """, """
            DROP VIEW IF EXISTS equipment_return_debt_view;
        """),

        migrations.RunSQL("""
            CREATE OR REPLACE VIEW monetary_debt_view AS
            SELECT
                cl.id AS client_id,
                cl.email,
                cl.phone_number,
                CASE 
                    WHEN cl.type = 'individual' THEN 
                        CONCAT(ind.last_name, ' ', ind.first_name, 
                            CASE WHEN ind.patronymic IS NOT NULL THEN ' ' || ind.patronymic ELSE '' END)
                    WHEN cl.type = 'company' THEN comp.company_name
                    ELSE 'Неизвестный тип клиента'
                END AS client_name,
                cl.type AS client_type,
                r.id AS rent_id,
                r.rent_agreement_number,
                r.total_amount,
                r.start_date,
                r.planned_end_date,
                r.actual_end_date,
                (CURRENT_DATE - r.start_date) AS rent_duration_days
            FROM rental_system_rent r
            JOIN rental_system_client cl ON r.client_id = cl.id
            LEFT JOIN rental_system_indclient ind ON ind.client_id = cl.id AND cl.type = 'individual'
            LEFT JOIN rental_system_compclient comp ON comp.client_id = cl.id AND cl.type = 'company'
            WHERE r.is_paid = FALSE;
        """, """
            DROP VIEW IF EXISTS monetary_debt_view;
        """),


        migrations.RunSQL("""
            CREATE OR REPLACE VIEW maintenance_schedule_view AS
            SELECT
                m.id AS maintenance_id,
                m.maintenance_date,
                e.id AS equipment_id,
                e.equipment_name,
                u.id AS staff_id,
                u.first_name,
                u.last_name,
                m.description,
                m.status
            FROM rental_system_maintenance m
            JOIN rental_system_equipment e ON m.equipment_id = e.id
            LEFT JOIN auth_user u ON m.staff_id = u.id
            ORDER BY m.maintenance_date;
        """, """
            DROP VIEW IF EXISTS maintenance_schedule_view;
        """),

        # Триггеры
        migrations.RunSQL("""
            CREATE OR REPLACE FUNCTION log_table_changes()
            RETURNS TRIGGER AS $$
            DECLARE
                v_action_type TEXT;
                v_description TEXT;
                v_old_data JSONB;
                v_new_data JSONB;
                v_changed_fields TEXT[];
                v_field TEXT;
            BEGIN
                -- Определяем тип действия
                IF TG_OP = 'INSERT' THEN
                    v_action_type := 'CREATE';
                    v_new_data := to_jsonb(NEW);
                    v_description := CONCAT(
                        'Создан новый объект в таблице ', TG_TABLE_NAME,
                        '. Данные: ', v_new_data::TEXT
                    );
                    
                ELSIF TG_OP = 'UPDATE' THEN
                    v_action_type := 'UPDATE';
                    v_old_data := to_jsonb(OLD);
                    v_new_data := to_jsonb(NEW);
                    
                    -- Находим измененные поля
                    v_changed_fields := ARRAY[]::TEXT[];
                    FOR v_field IN SELECT jsonb_object_keys(v_old_data) LOOP
                        IF v_old_data->>v_field IS DISTINCT FROM v_new_data->>v_field THEN
                            v_changed_fields := array_append(v_changed_fields, 
                                CONCAT(v_field, ': ', COALESCE(v_old_data->>v_field, 'NULL'), ' → ', COALESCE(v_new_data->>v_field, 'NULL'))
                            );
                        END IF;
                    END LOOP;
                    
                    v_description := CONCAT(
                        'Обновлен объект в таблице ', TG_TABLE_NAME,
                        '. ID: ', COALESCE(OLD.id::TEXT, NEW.id::TEXT),
                        '. Измененные поля: ', array_to_string(v_changed_fields, '; ')
                    );
                    
                ELSIF TG_OP = 'DELETE' THEN
                    v_action_type := 'DELETE';
                    v_old_data := to_jsonb(OLD);
                    v_description := CONCAT(
                        'Удален объект из таблицы ', TG_TABLE_NAME,
                        '. ID: ', OLD.id::TEXT,
                        '. Данные: ', v_old_data::TEXT
                    );
                    
                END IF;

                -- Вставляем запись в лог
                INSERT INTO rental_system_log(
                    action_type, 
                    description_text,
                    success_status
                ) VALUES (
                    v_action_type,
                    v_description,
                    TRUE
                );

                RETURN CASE 
                    WHEN TG_OP = 'DELETE' THEN OLD 
                    ELSE NEW 
                END;
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS log_table_changes CASCADE;
        """),
        
        migrations.RunSQL("""
            -- Триггерная функция для логирования входа/выхода
            CREATE OR REPLACE FUNCTION log_auth_events()
            RETURNS TRIGGER AS $$
            DECLARE
                v_action_type TEXT;
                v_description TEXT;
            BEGIN
                IF TG_OP = 'INSERT' THEN
                    -- Предполагаем, что есть таблица auth_events для событий аутентификации
                    v_action_type := UPPER(NEW.event_type);
                    v_description := CONCAT(
                        'Событие аутентификации: ', NEW.event_type,
                        '. Пользователь: ', COALESCE(NEW.username, 'Unknown'),
                        '. IP: ', COALESCE(NEW.ip_address, 'Unknown'),
                        '. Успех: ', NEW.success
                    );
                    
                    -- Определяем конкретный тип действия на основе event_type
                    IF NEW.event_type = 'login' AND NEW.success THEN
                        v_action_type := 'LOGIN';
                    ELSIF NEW.event_type = 'login' AND NOT NEW.success THEN
                        v_action_type := 'LOGIN_FAILED';
                    ELSIF NEW.event_type = 'logout' THEN
                        v_action_type := 'LOGOUT';
                    END IF;
                    
                END IF;

                INSERT INTO rental_system_log(
                    staff_id,
                    action_type, 
                    description_text,
                    success_status
                ) VALUES (
                    (SELECT id FROM auth_user WHERE username = NEW.username LIMIT 1),
                    v_action_type,
                    v_description,
                    NEW.success
                );

                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            -- Триггерная функция для логирования изменений статусов
            CREATE OR REPLACE FUNCTION log_status_changes()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = 'UPDATE' AND OLD.status IS DISTINCT FROM NEW.status THEN
                    INSERT INTO rental_system_log(
                        action_type, 
                        description_text,
                        success_status
                    ) VALUES (
                        'CHANGE_STATUS',
                        CONCAT(
                            'Изменен статус в таблице ', TG_TABLE_NAME,
                            '. ID: ', OLD.id::TEXT,
                            '. Статус: ', COALESCE(OLD.status::TEXT, 'NULL'), 
                            ' → ', COALESCE(NEW.status::TEXT, 'NULL')
                        ),
                        TRUE
                    );
                END IF;

                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            -- Триггерная функция для логирования назначений
            CREATE OR REPLACE FUNCTION log_assignments()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = 'UPDATE' AND OLD.staff_id IS DISTINCT FROM NEW.staff_id THEN
                    INSERT INTO rental_system_log(
                        action_type, 
                        description_text,
                        success_status
                    ) VALUES (
                        'ASSIGN',
                        CONCAT(
                            'Изменено назначение в таблице ', TG_TABLE_NAME,
                            '. ID: ', OLD.id::TEXT,
                            '. Сотрудник: ', COALESCE(OLD.staff_id::TEXT, 'NULL'), 
                            ' → ', COALESCE(NEW.staff_id::TEXT, 'NULL')
                        ),
                        TRUE
                    );
                END IF;

                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS log_auth_events CASCADE;
            DROP FUNCTION IF EXISTS log_status_changes CASCADE;
            DROP FUNCTION IF EXISTS log_assignments CASCADE;
        """),
        
        migrations.RunSQL("""
            -- Основной триггер для всех таблиц
            CREATE TRIGGER log_equipment_changes
                AFTER INSERT OR UPDATE OR DELETE ON rental_system_equipment
                FOR EACH ROW EXECUTE FUNCTION log_table_changes();

            CREATE TRIGGER log_client_changes
                AFTER INSERT OR UPDATE OR DELETE ON rental_system_client
                FOR EACH ROW EXECUTE FUNCTION log_table_changes();

            CREATE TRIGGER log_rent_changes
                AFTER INSERT OR UPDATE OR DELETE ON rental_system_rent
                FOR EACH ROW EXECUTE FUNCTION log_table_changes();

            -- Специализированные триггеры для статусов
            CREATE TRIGGER log_equipment_status_changes
                AFTER UPDATE ON rental_system_equipment
                FOR EACH ROW EXECUTE FUNCTION log_status_changes();

            CREATE TRIGGER log_rent_status_changes
                AFTER UPDATE ON rental_system_rent
                FOR EACH ROW EXECUTE FUNCTION log_status_changes();

            CREATE TRIGGER log_maintenance_status_changes
                AFTER UPDATE ON rental_system_maintenance
                FOR EACH ROW EXECUTE FUNCTION log_status_changes();

            -- Триггер для назначений
            CREATE TRIGGER log_maintenance_assignments
                AFTER UPDATE ON rental_system_maintenance
                FOR EACH ROW EXECUTE FUNCTION log_assignments();
        """, """
            DROP TRIGGER IF EXISTS log_equipment_changes ON rental_system_equipment;
            DROP TRIGGER IF EXISTS log_client_changes ON rental_system_client;
            DROP TRIGGER IF EXISTS log_rent_changes ON rental_system_rent;
            DROP TRIGGER IF EXISTS log_equipment_status_changes ON rental_system_equipment;
            DROP TRIGGER IF EXISTS log_rent_status_changes ON rental_system_rent;
            DROP TRIGGER IF EXISTS log_maintenance_status_changes ON rental_system_maintenance;
            DROP TRIGGER IF EXISTS log_maintenance_assignments ON rental_system_maintenance;
        """),

        migrations.RunSQL("""
            CREATE OR REPLACE FUNCTION set_equipment_rented()
            RETURNS TRIGGER AS $$
            BEGIN
                UPDATE erental_system_equipment
                SET status = 'rented'
                WHERE id = NEW.equipment_id;

                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        """, """
            DROP FUNCTION IF EXISTS set_equipment_rented CASCADE;
        """),
        
        migrations.RunSQL("""
            CREATE TRIGGER set_equipment_rented
            AFTER INSERT ON rental_system_rentitems
            FOR EACH ROW EXECUTE FUNCTION set_equipment_rented();
        """, """
            DROP TRIGGER IF EXISTS set_equipment_rented ON rental_system_rentitems;
        """),

        ## процедуры
        migrations.RunSQL("""
            CREATE OR REPLACE PROCEDURE add_equipment(
                p_equipment_name VARCHAR,
                p_equipment_code VARCHAR,
                p_description TEXT,
                p_model_id INT,
                p_country_id INT,
                p_brand_id INT,
                p_power NUMERIC,
                p_weight NUMERIC,
                p_fuel_type VARCHAR,
                p_rental_price_day NUMERIC,
                p_staff_id INT
            )
            LANGUAGE plpgsql
            AS $$
            DECLARE
                v_equipment_id INT;
            BEGIN
                INSERT INTO rental_system_equipment(
                    equipment_name, equipment_code, description, model_id, country_id, brand_id,
                    power, weight, fuel_type, rental_price_day, status
                ) VALUES (
                    p_equipment_name, p_equipment_code, p_description, p_model_id, p_country_id, p_brand_id,
                    p_power, p_weight, p_fuel_type, p_rental_price_day, 'available'
                )
                RETURNING id INTO v_equipment_id;

                INSERT INTO rental_system_log(staff_id, action_type, description_text)
                VALUES (p_staff_id, 'CREATE', CONCAT('Добавлено оборудование: ', p_equipment_name));
            END;
            $$;
        """, """
            DROP PROCEDURE IF EXISTS add_equipment;
        """),

        migrations.RunSQL("""
            CREATE OR REPLACE PROCEDURE register_payment(
                p_rent_id INT,
                p_payment_method VARCHAR,
                p_transaction_number VARCHAR,
                p_payment_date DATE
            )
            LANGUAGE plpgsql
            AS $$
            BEGIN
                UPDATE rental_system_rent
                SET is_paid = TRUE,
                    payment_method = p_payment_method,
                    transaction_number = p_transaction_number,
                    payment_date = p_payment_date
                WHERE id = p_rent_id;
            END;
            $$;
        """, """
            DROP PROCEDURE IF EXISTS register_payment;
        """),

        
        migrations.RunSQL("""
            CREATE OR REPLACE PROCEDURE complete_rent(p_rent_id INT, p_actual_end_date DATE)
            LANGUAGE plpgsql
            AS $$
            DECLARE
                v_equipment_id INT;
            BEGIN
                -- обновляем аренду
                UPDATE rental_system_rent
                SET rent_status = 'completed',
                    actual_end_date = p_actual_end_date
                WHERE id = p_rent_id;

                -- возвращаем оборудование
                FOR v_equipment_id IN
                    SELECT equipment_id FROM rental_system_rentitems WHERE rent_id = p_rent_id
                LOOP
                    UPDATE rental_system_equipment
                    SET status = 'available'
                    WHERE id = v_equipment_id;
                END LOOP;
            END;
            $$;
        """, """
            DROP PROCEDURE IF EXISTS complete_rent;
        """),
    ]
